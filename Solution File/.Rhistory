View(binary_returns_df)
setwd("C:/prescient-coding-challenge-2024/Solution File")
traindat = read.csv("traindat.csv")
traindat$industry = as.factor(traindat$industry)
equities = unique(traindat$)
equities = unique(traindat$Company)
equities
N = dim(traindat)[1]
set.seed(2024)
set = sample(1:N,floor(0.5*N), replace = FALSE)
data_train = as.h2o(traindat[set,])
data_val   = as.h2o(traindat[-set,])
traindat = as.h2o(traindat)
m = ncol(traindat)
traindat = read.csv("traindat.csv")
traindat$industry = as.factor(traindat$industry)
equities = unique(traindat$Company)
library(h2o)
h2o.init()
N = dim(traindat)[1]
set.seed(2024)
set = sample(1:N,floor(0.5*N), replace = FALSE)
data_train = as.h2o(traindat[set,])
data_val   = as.h2o(traindat[-set,])
m = ncol(traindat)
View(traindat)
m = length(equities)
m = ncol(traindat)
model = h2o.deeplearning(x = 4:m,
y =3,
training_frame = data_train,
validation_frame = data_val,
standardize = TRUE,
hidden = c(5,5),
activation = 'Tanh',
distribution = 'gaussian',
loss = 'Quadratic',
l2 = 0.001,
rate = 0.01,
adaptive_rate = FALSE,
epochs = 1000,
reproducible = TRUE,
seed = 2024
)
k = length(equities)
dailyreturns = matrix(data = predictions_df,
ncols = k)
k = length(equities)
dailyreturns = matrix(data = predictions_df,
ncols = k)
# Load the new dataframe
testdat = read.csv("testdat.csv")
testdat$industry = as.factor(testdat$industry)
# Convert the new dataframe to an H2O object
testdat_h2o = as.h2o(testdat)
# Make predictions using the trained model
predictions = h2o.predict(model, testdat_h2o)
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
k = length(equities)
dailyreturns = matrix(data = predictions_df,
ncols = k)
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
dailyreturns = matrix(data = predictions_df,
ncols = k)
k = length(equities)
dailyreturns = matrix(data = predictions_df,
ncols = k)
dailyreturns = matrix(data = predictions_df,
ncol = k)
View(dailyreturns)
head(dailyreturns)
View(dailyreturns)
k = length(equities)
dailyreturns = matrix(data = predictions_df,
ncol = k, byrow = TRUE)
dailyreturns = matrix(data = predictions_df,
ncol = k, byrow = TRUE)
dailyreturns = matrix(data = predictions_df, ncol = k, byrow = TRUE)
View(dailyreturns)
dailyreturns = matrix(data = predictions_df, ncol = k, byrow = TRUE)
k
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
dailyreturns = matrix(data = predictions_df, ncol = k, byrow = TRUE)
traindat = read.csv("traindat.csv")
traindat$industry = as.factor(traindat$industry)
equities = unique(traindat$Company)
library(h2o)
h2o.init()
N = dim(traindat)[1]
set.seed(2024)
set = sample(1:N,floor(0.5*N), replace = FALSE)
data_train = as.h2o(traindat[set,])
data_val   = as.h2o(traindat[-set,])
m = ncol(traindat)
model = h2o.deeplearning(x = 4:m,
y =3,
training_frame = data_train,
validation_frame = data_val,
standardize = TRUE,
hidden = c(5,5),
activation = 'Tanh',
distribution = 'gaussian',
loss = 'Quadratic',
l2 = 0.001,
rate = 0.01,
adaptive_rate = FALSE,
epochs = 1000,
reproducible = TRUE,
seed = 2024
)
# Load the new dataframe
testdat = read.csv("testdat.csv")
testdat$industry = as.factor(testdat$industry)
# Convert the new dataframe to an H2O object
testdat_h2o = as.h2o(testdat)
# Make predictions using the trained model
predictions = h2o.predict(model, testdat_h2o)
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
# View predictions
print(head(predictions_df))
k = length(equities)
dailyreturns = matrix(data = predictions_df, ncol = k, byrow = TRUE)
predicted_values <- predictions_df$predict  # Use the correct column name
# Create the daily returns matrix
dailyreturns = matrix(data = predicted_values, ncol = k, byrow = TRUE)
View(dailyreturns)
head(dailyreturns)
convert_top_10 <- function(column) {
top_10_indices <- order(column, decreasing = TRUE)[1:10]  # Get indices of top 10 returns
binary_column <- ifelse(1:length(column) %in% top_10_indices, 1, 0)  # Convert to 1s and 0s
return(binary_column)
}
# Apply the function to each column
binary_returns_df <- as.data.frame(apply(dailyreturns, 2, convert_top_10))
# View the resulting dataframe
print(binary_returns_df)
View(binary_returns_df)
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
View(binary_returns_df)
# View the resulting dataframe
print(binary_returns_df)
# Ensure each row sums to 1
row_sums <- rowSums(binary_returns_df)
print(head(row_sums))  # Check that each row sums to 1
trading_rets = testdat$return1 %*%binary_returns_df
trading_rets = t(testdat$return1) %*%binary_returns_df
trading_rets = t(testdat$return1) %*%as.matrix(binary_returns_df)
trading_rets = testdat$return1 %*%as.matrix(binary_returns_df)
View(binary_returns_df)
testrets = matrix(data = testdat$return1,
ncol = k, byrow = TRUE)
View(testrets)
rets = testrets%*%binary_returns_df
rets = as.matrix(testrets)%*%as.matri(binary_returns_df)
rets = as.matrix(testrets)%*%as.matrix(binary_returns_df)
rets = t(as.matrix(testrets))%*%as.matrix(binary_returns_df)
View(testrets)
rets = as.matrix(testrets)%*%t(as.matrix(binary_returns_df))
View(rets)
rets = as.matrix(testrets)%*%t(as.matrix(binary_returns_df))
View(rets)
testrets[1]
testrets[,1]
testrets[1,]
testrets[1,]%*%binary_returns_df[1,]
t(testrets[1,])%*%binary_returns_df[1,]
t(as.matrix(testrets[1,])%*%as.matrix(binary_returns_df[1,])
t(as.matrix(testrets[1,])%*%as.matrix(binary_returns_df[1,])
as.matrix(testrets[1,]
t(as.matrix(testrets[1,]))%*%as.matrix(binary_returns_df[1,])
as.matrix(testrets[1,])%*%as.matrix(binary_returns_df[1,])
as.matrix(testrets[1,])%*%t(as.matrix(binary_returns_df[1,]))
t(as.matrix(binary_returns_df[1,]))%*%as.matrix(testrets[1,])
as.matrix(binary_returns_df[1,])%*%as.matrix(testrets[1,])
q = nrow(testrets)
tradingretsmat = matrix(NA,nrow = q)
for (i in 1:q) {
tradingretsmat[i,] = as.matrix(binary_returns_df[i,])%*%as.matrix(testrets[i,])
}
returns = cumprod(tradingretsmat+1)-1
returns
returns = cumprod(tradingretsmat+1)
returns
plot(returns, type = "l")
setwd("C:/prescient-coding-challenge-2024/Solution File")
traindat = read.csv("traindat.csv")
traindat$industry = as.factor(traindat$industry)
traindat$X10dayrollingstddev = NULL
equities = unique(traindat$Company)
N = dim(traindat)[1]
set.seed(2024)
set = sample(1:N,floor(0.5*N), replace = FALSE)
data_train = as.h2o(traindat[set,])
data_val   = as.h2o(traindat[-set,])
m = ncol(traindat)
model = h2o.deeplearning(x = 4:m,
y =3,
training_frame = data_train,
validation_frame = data_val,
standardize = TRUE,
hidden = c(5,5),
activation = 'Tanh',
distribution = 'gaussian',
loss = 'Quadratic',
l2 = 0.001,
rate = 0.01,
adaptive_rate = FALSE,
epochs = 1000,
reproducible = TRUE,
seed = 2024
)
# Load the new dataframe
testdat = read.csv("testdat.csv")
testdat$industry = as.factor(testdat$industry)
# Convert the new dataframe to an H2O object
testdat_h2o = as.h2o(testdat)
# Make predictions using the trained model
predictions = h2o.predict(model, testdat_h2o)
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
# View predictions
print(head(predictions_df))
k = length(equities)
predicted_values <- predictions_df$predict
dailyreturns = matrix(data = predicted_values, ncol = k, byrow = TRUE)
# View the resulting matrix
print(dailyreturns)
dailyreturns = matrix(data = predictions_df, ncol = k, byrow = TRUE)
head(dailyreturns)
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
setwd("C:/prescient-coding-challenge-2024/Solution File")
traindat = read.csv("traindat.csv")
traindat$industry = as.factor(traindat$industry)
traindat$X10dayrollingstddev = NULL
equities = unique(traindat$Company)
N = dim(traindat)[1]
set.seed(2024)
set = sample(1:N,floor(0.5*N), replace = FALSE)
data_train = as.h2o(traindat[set,])
data_val   = as.h2o(traindat[-set,])
m = ncol(traindat)
model = h2o.deeplearning(x = 4:m,
y =3,
training_frame = data_train,
validation_frame = data_val,
standardize = TRUE,
hidden = c(5,5),
activation = 'Tanh',
distribution = 'gaussian',
loss = 'Quadratic',
l2 = 0.001,
rate = 0.01,
adaptive_rate = FALSE,
epochs = 1000,
reproducible = TRUE,
seed = 2024
)
# Load the new dataframe
testdat = read.csv("testdat.csv")
testdat$industry = as.factor(testdat$industry)
# Convert the new dataframe to an H2O object
testdat_h2o = as.h2o(testdat)
# Make predictions using the trained model
predictions = h2o.predict(model, testdat_h2o)
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
# View predictions
print(head(predictions_df))
k = length(equities)
predicted_values <- predictions_df$predict
dailyreturns = matrix(data = predicted_values, ncol = k, byrow = TRUE)
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
# View the resulting dataframe
print(head(binary_returns_df))
# Ensure each row sums to 1 (optional)
row_sums <- rowSums(binary_returns_df)
# Apply the function to each row
binary_returns_df <- as.data.frame(t(apply(dailyreturns, 1, convert_top_10)))
# View the resulting dataframe
print(binary_returns_df)
testrets = matrix(data = testdat$return1,
ncol = k, byrow = TRUE)
q = nrow(testrets)
tradingretsmat = matrix(NA,nrow = q)
for (i in 1:q) {
tradingretsmat[i,] = as.matrix(binary_returns_df[i,])%*%as.matrix(testrets[i,])
}
returns = cumprod(tradingretsmat+1)
plot(returns, type = "l")
testdat$Date
timeindex = as.date(testdat$Date)
timeindex = as.Date(testdat$Date)
plot(y = returns, x = timeindex, type = "l",xlab = "Price Index", ylab = "Time")
timeindex = as.Date(testdat$Date)
length(testdat)
nrow(testdat)
length(predictions_df)
length(predicted_values)
binary_returns_df
nrow(binary_returns_df)
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row of the dailyreturns matrix
binary_returns_matrix <- t(apply(dailyreturns, 1, convert_top_10))
# Convert the result back to a dataframe if needed
binary_returns_df <- as.data.frame(binary_returns_matrix)
# Apply the function to each row of the dailyreturns matrix
binary_returns_matrix <- t(apply(dailyreturns, 1, convert_top_10))
testrets = matrix(data = testdat$return1,
ncol = k, byrow = TRUE)
testrets
traindat = read.csv("traindat.csv")
traindat$industry = as.factor(traindat$industry)
traindat$X10dayrollingstddev = NULL
equities = unique(traindat$Company)
library(h2o)
N = dim(traindat)[1]
set.seed(2024)
set = sample(1:N,floor(0.5*N), replace = FALSE)
data_train = as.h2o(traindat[set,])
data_val   = as.h2o(traindat[-set,])
m = ncol(traindat)
model = h2o.deeplearning(x = 4:m,
y =3,
training_frame = data_train,
validation_frame = data_val,
standardize = TRUE,
hidden = c(5,5),
activation = 'Tanh',
distribution = 'gaussian',
loss = 'Quadratic',
l2 = 0.001,
rate = 0.01,
adaptive_rate = FALSE,
epochs = 1000,
reproducible = TRUE,
seed = 2024
)
# Load the new dataframe
testdat = read.csv("testdat.csv")
testdat$industry = as.factor(testdat$industry)
# Convert the new dataframe to an H2O object
testdat_h2o = as.h2o(testdat)
# Make predictions using the trained model
predictions = h2o.predict(model, testdat_h2o)
# Convert predictions back to R data frame if needed
predictions_df = as.data.frame(predictions)
k = length(equities)
predicted_values <- predictions_df$predict
dailyreturns = matrix(data = predicted_values, ncol = k, byrow = TRUE)
# Function to find the top 10 returns for each row and replace them with 0.1, setting the rest to 0
convert_top_10 <- function(row) {
top_10_indices <- order(row, decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_row <- rep(0, length(row))  # Initialize all values to 0
binary_row[top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
return(binary_row)
}
# Apply the function to each row of the dailyreturns matrix
binary_returns_matrix <- t(apply(dailyreturns, 1, convert_top_10))
testrets = matrix(data = testdat$return1,
ncol = k, byrow = TRUE)
q = nrow(testrets)
tradingretsmat = matrix(NA,nrow = q)
for (i in 1:q) {
tradingretsmat[i,] = as.matrix(binary_returns_matrix[i,])%*%as.matrix(testrets[i,])
}
binary_returns_matrix[1,]
testrets[1,]
for (i in 1:q) {
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
}
returns = cumprod(tradingretsmat+1)
plot(y = returns, x = timeindex, type = "l",xlab = "Price Index", ylab = "Time")
plot(y = returns, type = "l",xlab = "Price Index", ylab = "Time")
plot(y = returns, type = "l", ylab = "Time")
returns
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
for (i in 1:q) {
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
}
tradingretsmat = matrix(NA,nrow = nrow(testdat))
for (i in 1:q) {
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
}
tradingretsmat
for (i in 1:(nrow((testdat)))) {
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
}
tradingretsmat
q = nrow(testdat)
tradingretsmat = matrix(NA,nrow = q)
for (i in 1:q) {
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
}
tradingretsmat
q = nrow(testdat)
tradingretsmat = matrix(NA,nrow = q)
binary_returns_matrix
# Apply the function to each row of the dailyreturns matrix
binary_returns_matrix <- t(apply(dailyreturns, 1, convert_top_10))
binary_returns_matrix
install.packages("purrr")
library(purrr)
# Initialize an empty matrix to store binary results
binary_returns_matrix <- matrix(0, nrow = nrow(dailyreturns), ncol = ncol(dailyreturns))
# Loop through each row to fill binary_returns_matrix
for (i in 1:nrow(dailyreturns)) {
top_10_indices <- order(dailyreturns[i, ], decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_returns_matrix[i, top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
}
# Convert to data frame if needed
binary_returns_df <- as.data.frame(binary_returns_matrix)
View(binary_returns_matrix)
predicted_values <- predictions_df$predict
dailyreturns = matrix(data = predicted_values, ncol = k, byrow = TRUE)
# Initialize an empty matrix to store binary results
binary_returns_matrix <- matrix(0, nrow = nrow(dailyreturns), ncol = ncol(dailyreturns))
# Loop through each row to fill binary_returns_matrix
for (i in 1:nrow(dailyreturns)) {
top_10_indices <- order(dailyreturns[i, ], decreasing = TRUE)[1:10]  # Get indices of the top 10 returns
binary_returns_matrix[i, top_10_indices] <- 0.1  # Set the top 10 returns to 0.1
}
# Convert to data frame if needed
binary_returns_df <- as.data.frame(binary_returns_matrix)
# Confirm the dimensions of the new binary dataframe
print(dim(binary_returns_df))  # Should be (74542, k)
# View the first few rows to confirm correctness
print(head(binary_returns_df))
# Ensure each row sums to 1
row_sums <- rowSums(binary_returns_df)
print(head(row_sums))  # Should be all 1s
testrets = matrix(data = testdat$return1,
ncol = k, byrow = TRUE)
q = nrow(testdat)
tradingretsmat = matrix(NA,nrow = q)
for (i in 1:q) {
tradingretsmat[i,] = t(as.matrix(binary_returns_matrix[i,]))%*%as.matrix(testrets[i,])
}
q = nrow(binary_returns_df)
tradingretsmat = matrix(NA,nrow = q)
for (i in 1:q) {
tradingretsmat[i,] = t(as.matrix(binary_returns_df[i,]))%*%as.matrix(testrets[i,])
}
for (i in 1:q) {
tradingretsmat[i,] = as.matrix(binary_returns_df[i,])%*%as.matrix(testrets[i,])
}
tradingretsmat
returns = cumprod(tradingretsmat+1)
returns
plot(y = returns, type = "l", ylab = "Time")
timeindex = as.Date(testdat$Date)
timeindex = unique(testdat$Date)
timeindex = as.Date(unique(testdat$Date))
plot(y = returns,x = timeindex, type = "l", ylab = "Time")
length(returns)
length(timeindex)
l = length(returns)
plot(y = returns,x = 1:l , type = "l", ylab = "Time")
print(binary_returns_df)
